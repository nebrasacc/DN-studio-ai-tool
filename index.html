<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />
  <title>DN AI Studio — Ultra Storyboard (Pro)</title>
  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React 18 (UMD) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Babel for in-browser JSX transform -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    /* Optional: tiny utility for 2xs text (used in the component) */
    .text-2xs { font-size: 0.7rem; line-height: 1rem; }
  </style>
</head>
<body class="bg-black">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    /****************************
     * DN AI Studio — Ultra Storyboard App (Pro)
     * Embedded single-file build (React + Tailwind via CDNs)
     ****************************/

    /************ Utilities ************/
    const cn = (...a) => a.filter(Boolean).join(" ");
    const now = () => performance.now();
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    // Simple hash for cache keys
    async function sha256(text) {
      const buf = new TextEncoder().encode(text);
      const digest = await crypto.subtle.digest("SHA-256", buf);
      return Array.from(new Uint8Array(digest)).map(b => b.toString(16).padStart(2, "0")).join("");
    }

    /************ IndexedDB Cache ************/
    const idb = (() => {
      let dbPromise;
      function getDB() {
        if (!('indexedDB' in window)) return null;
        if (!dbPromise) {
          dbPromise = new Promise((resolve, reject) => {
            const req = indexedDB.open('dn-ai-pro-cache', 1);
            req.onupgradeneeded = () => req.result.createObjectStore('images');
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });
        }
        return dbPromise;
      }
      return {
        async get(key) {
          const db = await getDB();
          if (!db) return null;
          return new Promise((resolve, reject) => {
            const tx = db.transaction('images', 'readonly');
            const req = tx.objectStore('images').get(key);
            req.onsuccess = () => resolve(req.result || null);
            req.onerror = () => reject(req.error);
          });
        },
        async set(key, value) {
          const db = await getDB();
          if (!db) return false;
          return new Promise((resolve, reject) => {
            const tx = db.transaction('images', 'readwrite');
            tx.objectStore('images').put(value, key);
            tx.oncomplete = () => resolve(true);
            tx.onerror = () => reject(tx.error);
          });
        }
      };
    })();

    /************ Worker for branding ************/
    function makeBrandWorker() {
      const code = `self.onmessage = async (e) => {
        const { base, logo, opacity, pad } = e.data;
        try {
          const [baseBmp, logoBmp] = await Promise.all([
            createImageBitmap(await (await fetch(base)).blob()),
            createImageBitmap(await (await fetch(logo)).blob())
          ]);
          const off = new OffscreenCanvas(baseBmp.width, baseBmp.height);
          const ctx = off.getContext('2d');
          ctx.drawImage(baseBmp, 0, 0);
          const logoH = baseBmp.height * 0.08;
          const logoW = (logoBmp.width / logoBmp.height) * logoH;
          const x = baseBmp.width - logoW - baseBmp.width * (pad || 0.025);
          const y = baseBmp.height - logoH - baseBmp.height * (pad || 0.025);
          ctx.globalAlpha = opacity ?? 0.9;
          ctx.drawImage(logoBmp, x, y, logoW, logoH);
          const blob = await off.convertToBlob({ type: 'image/png' });
          const url = URL.createObjectURL(blob);
          self.postMessage({ ok: true, url });
        } catch (err) {
          self.postMessage({ ok: false, error: String(err) });
        }
      };`;
      const blob = new Blob([code], { type: 'application/javascript' });
      // Module workers from Blob are widely supported; classic also works.
      try {
        return new Worker(URL.createObjectURL(blob), { type: 'module' });
      } catch {
        return new Worker(URL.createObjectURL(blob));
      }
    }

    /************ Queue with concurrency + retry ************/
    class TaskQueue {
      constructor(max = 3) {
        this.max = max; this.running = 0; this.q = []; this.onChange = () => {};
      }
      setMax(n) { this.max = Math.max(1, n); this.tick(); }
      push(task) { this.q.push(task); this.tick(); }
      clear() { this.q.length = 0; }
      async tick() {
        while (this.running < this.max && this.q.length) {
          const t = this.q.shift();
          this.running++; this.onChange(this);
          t().finally(() => { this.running--; this.onChange(this); this.tick(); });
        }
      }
    }

    /************ Core App ************/
    function UltraStoryboardApp() {
      // Config & state
      const [imageModel, setImageModel] = useState("gemini-2.5-flash-image-preview");
      const [textModel, setTextModel]   = useState("gemini-2.5-flash-preview-05-20");
      const [visualStyle, setVisualStyle] = useState("Cinematic Photorealistic");
      const [narrative, setNarrative] = useState("MYKOOD Campaign Video Script\n\nScene 1: Opening Shot ...");
      const [refImg, setRefImg] = useState(null);
      const [logoImg, setLogoImg] = useState(null);
      const [brandOn, setBrandOn] = useState(true);
      const [charLock, setCharLock] = useState(true);
      const [predicted, setPredicted] = useState(null);
      const [scenes, setScenes] = useState([]);
      const [busy, setBusy] = useState(false);
      const [status, setStatus] = useState("Ready.");
      const [err, setErr] = useState(null);
      const [shotSuggestions, setShotSuggestions] = useState({ sceneId: null, suggestions: [], loading: false });
      const [musicSuggestion, setMusicSuggestion] = useState(null);

      // Performance
      const [maxConcurrent, setMaxConcurrent] = useState(4);
      const [retryCount, setRetryCount] = useState(2);
      const [retryDelay, setRetryDelay] = useState(1500);

      // Stats
      const [startedAt, setStartedAt] = useState(null);
      const [finishedAt, setFinishedAt] = useState(null);
      const [genCount, setGenCount] = useState(0);
      const avgMsPerImg = useMemo(() => {
        if (!startedAt || genCount === 0) return null;
        const ms = (performance.now() - startedAt) / genCount; return ms;
      }, [startedAt, genCount]);

      // Queue
      const queueRef = useRef(new TaskQueue(maxConcurrent));
      useEffect(() => { queueRef.current.setMax(maxConcurrent); }, [maxConcurrent]);

      // Persist lightweight config
      useEffect(() => {
        const saved = localStorage.getItem('dn-ai-pro-config');
        if (saved) {
          try { const j = JSON.parse(saved);
            setImageModel(j.imageModel ?? imageModel);
            setTextModel(j.textModel ?? textModel);
            setVisualStyle(j.visualStyle ?? visualStyle);
            setMaxConcurrent(j.maxConcurrent ?? maxConcurrent);
          } catch {}
        }
      // eslint-disable-next-line
      }, []);
      useEffect(() => {
        localStorage.setItem('dn-ai-pro-config', JSON.stringify({ imageModel, textModel, visualStyle, maxConcurrent }));
      }, [imageModel, textModel, visualStyle, maxConcurrent]);

      // Helpers
      const loadExternal = (src) => new Promise((res, rej) => {
        if (document.querySelector(\`script[src="\${src}"]\`)) return res();
        const s = document.createElement('script'); s.src = src; s.onload = res; s.onerror = () => rej(new Error('Failed '+src)); document.body.appendChild(s);
      });

      async function importPdf(file) {
        setErr(null); setStatus('Loading PDF.js ...');
        await loadExternal('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js');
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
        setStatus('Reading PDF ...');
        const buf = new Uint8Array(await file.arrayBuffer());
        const pdf = await window.pdfjsLib.getDocument({ data: buf }).promise;
        let txt = '';
        for (let i=1;i<=pdf.numPages;i++) {
          const page = await pdf.getPage(i);
          const tc = await page.getTextContent();
          txt += tc.items.map(it => it.str).join(' ') + '\\n\\n';
        }
        setNarrative(txt.trim()); setStatus('PDF imported.');
      }

      function fileToBase64(file) { return new Promise((res, rej) => { const r = new FileReader(); r.onload = () => res(r.result); r.onerror = rej; r.readAsDataURL(file); }); }

      /** Text API **/
      async function callText(parts, system, jsonSchema) {
        const apiKey = "" // Leave as-is, framework will handle it
        const payload = { contents: [{ parts }], systemInstruction: system ? { parts: [{ text: system }] } : undefined };
        if (jsonSchema) payload.generationConfig = { responseMimeType: 'application/json', responseSchema: jsonSchema };
        const url = \`https://generativelanguage.googleapis.com/v1beta/models/\${textModel}:generateContent?key=\${apiKey}\`;
        const r = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!r.ok) throw new Error((await r.json()).error?.message || r.statusText);
        const j = await r.json();
        return j.candidates?.[0]?.content?.parts?.[0]?.text || '';
      }

      /** Image API **/
      async function callImage(promptText, refDataUrl) {
        const apiKey = "" // Leave as-is, framework will handle it
        const parts = [{ text: promptText }];
        if (refDataUrl) {
          const b64 = refDataUrl.split(',')[1];
          parts.push({ inlineData: { mimeType: 'image/png', data: b64 }});
        }
        const payload = { contents: [{ parts }], generationConfig: { responseModalities: ['IMAGE'] } };
        const url = \`https://generativelanguage.googleapis.com/v1beta/models/\${imageModel}:generateContent?key=\${apiKey}\`;
        const r = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!r.ok) throw new Error((await r.json()).error?.message || r.statusText);
        const j = await r.json();
        const base64 = j.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
        if (!base64) throw new Error('No image data returned');
        return \`data:image/png;base64,\${base64}\`;
      }

      /** Branding **/
      async function brandImage(baseUrl) {
        if (!brandOn || !logoImg) return baseUrl;
        if ('OffscreenCanvas' in window) {
          const worker = makeBrandWorker();
          return await new Promise((resolve) => {
            worker.onmessage = (e) => { if (e.data.ok) resolve(e.data.url); else resolve(baseUrl); worker.terminate(); };
            worker.postMessage({ base: baseUrl, logo: logoImg, opacity: 0.9, pad: 0.025 });
          });
        } else {
          // Fallback main-thread canvas
          const base = await (await fetch(baseUrl)).blob();
          const baseImg = await createImageBitmap(base);
          const logo = await (await fetch(logoImg)).blob();
          const logoBmp = await createImageBitmap(logo);
          const c = document.createElement('canvas'); c.width = baseImg.width; c.height = baseImg.height;
          const ctx = c.getContext('2d'); ctx.drawImage(baseImg,0,0);
          const h = c.height * 0.08; const w = (logoBmp.width/logoBmp.height)*h;
          const x = c.width - w - c.width*0.025; const y = c.height - h - c.height*0.025;
          ctx.globalAlpha = 0.9; ctx.drawImage(logoBmp, x, y, w, h);
          return c.toDataURL('image/png');
        }
      }

      /** Magic tools **/
      async function runMagic(tool) {
        try {
          setErr(null);
          if (!narrative)
